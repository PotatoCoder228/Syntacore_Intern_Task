## Задание для позиции Tools Intern Developer компании Syntacore.<br>

Со стандартного ввода приходят ключи(*k v*, каждый ключ *v* - это целое число, все ключи разные) и запросы двух
видов.<br>

- Запрос(*m i*) на поиск i-го наименьшего элемента(k-ая наименьшая статистика).<br>

- Запрос(*n j*) на поиск количества элементов, меньших, чем заданный *j*.<br>

Пример:<br>

* Вход: *k 8 k 2 k -1 m 1 m 2 n 3*<br>

* Результат: *-1 2 2*

Ключи могут быть как угодно перемешаны с запросами.<br>

Ваша задача — спроектировать и реализовать класс, представляющий собой расширенное
сбалансированное дерево, которое хранило бы ключи и предоставляло интерфейс для
выполнения запросов.

Чтобы добиться максимальной эффективности, вы должны продумать такую балансировку
дерева, чтобы оба вида запросов работали с логарифмической сложностью (из-за этого
ограничения вам скорее всего не подойдут стандартные контейнеры).
Возможные языки реализации - C++, Python или **C**. Для решения разрешается использовать только
средства языка и стандартной библиотеки, без дополнительных пакетов.
Придумайте несколько тестов для проверки вашего решения и реализуйте способ для их запуска в
виде консольного приложения. Тестовые данные можно подавать на стандартный ввод из
текстового файла.<br>

Бонусные задания:
Попробуйте корректно реализовать конструкторы, деструктор, итераторы для вашего класса.
Предусмотрите возможность сообщить пользователю об ошибках, которые могут быть допущены
во входном наборе данных.<br>

Решение должно быть оформлено в виде репозитория, опубликованного на github.com, и
передаваться в виде ссылки на него. Добавьте README-файл с описанием процесса сборки и
тестирования вашего проекта.

## Компиляция, линковка и запуск программы.

Клонирование репозитория в текущую директорию:

***git clone https://github.com/PotatoCoder228/Syntacore_Tools_Intern_Task.git***

**Действия для компиляции и линковки**:

В терминале в директории с проектом прописать следующую команду:

***cmake ./***

**Cmake** подготовит **Makefile** и цели в нём, поэтому достаточно написать название утилиты:

***make***

Если же у вас отсутствует утилита **cmake**, то можно воспользоваться вручную написанным **Makefile**, лежащим в
репозитории
(понадобится компилятор **gcc**, либо можно самому вписать нужный компилятор и флаги в **Makefile**):

**make** - компиляция и линковка основной программы;

**make clean** - очистка от файлов предыдущей компиляции;

**make test** - компиляция небольшого теста, для проверки расширенного красно-чёрного дерева.

## О тестировании

Для тестирования я написал тест внутри программы, который предназначен для тестирования
корректности вставки, поиска и удаления чисел из дерева, а также проверяющий соблюдение некоторых свойств
(в данном случае - соответствует ли число size свойствам расширенного красно-чёрного дерева для корректности операций).
Для запуска теста используется следующие команды:

***make сlean***

***make test***

В результате будет скомпилирована программа ***ApplicationTest***, которую можно запустить
и протестировать дерево.

Также был на языке Python 3 был написан маленький генератор файлов с текстовыми командами и программа для
проверки корректности вывода теста(в код "вшита" функция **write_test_answer** в **commands.c**, так как основные
функции вывода
терминала не очень подходят для вывода в файл результатов).
Тест проверяет команды и состояние дерева, с помощью отдельного текстового файла.

Для тестирования необходимо(понадобится интерпретатор Python 3):

* Сгенерировать текстовый файл в директории с приложением, запустив test_generator.py(числа берутся друг за другом, до
  100 тысяч,
  для более лёгкого алгоритма в тесте);
* Запустить основную программу;
* Воспользоваться командой *script* и там же ввести имя файла, откуда нужно считывать команды(в файле идут команды
  подряд, начиная с 1 строки,
  иначе ввод не будет корректным(программа посчитает, что на ввод ничего не подано));
* По умолчанию **write_test_answer** сначала выводит в файл все элементы в дереве в порядке возрастания, потом выполняет
  команды, результаты которых
  также выводятся в файл(**tree_values.txt**(если он отсутствует - он его создаёт)). К сожалению, при такой методике
  тестирования сложно как-то по другому организовать тест,
  кроме как грубо "вшитый" прогон со сравнением строк, поэтому я предпочёл бы написать тесты прям в коде, как я сделал
  один из "своих" тестов не по заданию;
* После выполнения скрипта - запустить **answers_checker.py** и ввести имя файла **tree_values.txt**(или своё, если
  меняли код основной программы);
* Готово, тестирование займёт некоторое время, а на выходе положительный или отрицательный результат.

## Примечание

Что реализовано:

* Расширенное красно-чёрное дерево, API для взаимодействия с ним(геттеры, сеттеры, foreach, деструктор, итератор),
  необходимые по заданию команды +
  некоторые дополнительные команды для взаимодействия с ним и вывода на экран;
* Написаны небольшие вспомогательные Python программы для генерации скрипта с командами и тест;
* "Внутренний" тест дерева, который тестирует вставку/удаление/поиск/корректность поля *size*
* Валидация ввода;
* Система обработки ошибок во время выполнения программы;